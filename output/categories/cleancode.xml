<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>The journal that counts (Posts about cleancode)</title><link>https://example.com/</link><description></description><atom:link rel="self" type="application/rss+xml" href="https://example.com/categories/cleancode.xml"></atom:link><language>en</language><copyright>Contents © 2017 &lt;a href="mailto:swinkels.pieter@yahoo.com"&gt;Pieter Swinkels&lt;/a&gt; </copyright><lastBuildDate>Sat, 28 Oct 2017 19:31:28 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>The Clean Architecture</title><link>https://example.com/posts/2017-09-06-the-clean-architecture.html</link><dc:creator>Pieter Swinkels</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;The Clean Architecture&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;

&lt;p&gt;
I googled for the terms Entities, Interactors and Boundaries and that lead me to
the following blog post by Martin from 2012, &lt;a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html"&gt;The Clean Architecture&lt;/a&gt;. In this
post he mentions several architectures from "the last several years":
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
Though these architectures all vary somewhat in their details, they are very
similar. They all have the same objective, which is the separation of concerns.
They all achieve this separation by dividing the software into layers.
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
The article describes the benefits of such an approach and the architectur it
leads to.
&lt;/p&gt;

&lt;p&gt;
This separation in layers is very related to guidelines I have tried to
follow for the last decade:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;each layer considers the system at one specific level of abstraction;
&lt;/li&gt;
&lt;li&gt;each layer builds upon other layers: those lower layers have a level of
abstraction that is equal to the current layer, or lower;
&lt;/li&gt;
&lt;li&gt;each layer has a well-defined interface and layers only communicate through
that interface;
&lt;/li&gt;
&lt;li&gt;each layer only talks to the layers below it.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
For me, designs that satisfy these requirements almost emerge automatically when
you do Test-Driven Development.
&lt;/p&gt;

&lt;p&gt;
Once caveat, the fact that I try to follow these guidelines does not mean I
always succeed…
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>architecture</category><category>cleancode</category><guid>https://example.com/posts/2017-09-06-the-clean-architecture.html</guid><pubDate>Wed, 06 Sep 2017 21:49:00 GMT</pubDate></item><item><title>Clean Code episode 7: Architecture, Use Cases and High Level Design</title><link>https://example.com/posts/2017-09-06-clean-code-episode-7--architecture--use-cases-and-high-level-design.html</link><dc:creator>Pieter Swinkels</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Clean Code episode 7: Architecture, Use Cases and High Level Design&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Yesterday and today I watched episode 7 of the Clean Code series on
architecture. It's a big episode that covers a lot of ground.
&lt;/p&gt;

&lt;p&gt;
In this episode, Martin states that the architecture should be determined by the
use cases. He uses use cases that are independent of the delivery mechanism of
the application (web interface, console interface, …), or the persistency
mechanism (flat files, relational database, …).
&lt;/p&gt;

&lt;p&gt;
That approach allows you to design the architecture independent of those
concerns. A good architecture should allow you to defer decisions related to
those concerns.
&lt;/p&gt;

&lt;p&gt;
During the episode, Robert Martin refers to several books among them
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Object Oriented Software Engineering: A Use Case Driven Approach, by Ivar
Jacobson, and
&lt;/li&gt;
&lt;li&gt;Agile Software Development, by Robert Martin.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
From the book by Jacobson he uses the distinction between Entities, Interactors
and Boundaries to discuss the main elements of an architecture.
&lt;/p&gt;

&lt;p&gt;
From his own book he uses a case study on how the first use cases drive the
initial architecture of a payroll system. That book is on my bookshelf, so maybe
it is time for a reread.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>architecture</category><category>cleancode</category><guid>https://example.com/posts/2017-09-06-clean-code-episode-7--architecture--use-cases-and-high-level-design.html</guid><pubDate>Wed, 06 Sep 2017 20:53:00 GMT</pubDate></item></channel></rss>